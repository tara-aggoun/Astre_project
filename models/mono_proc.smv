MODULE memory_module(b_in_L1)
	VAR
		state : {IDLE, READY};

	ASSIGN
		init(state) := IDLE;
		next(state) := case
			state = IDLE & b_in_L1 : READY;
			state = READY : IDLE;
			TRUE : state;
		esac;


-- end of memory_module

MODULE cpu_module(L1_req, L1_rsp)
	VAR
		req: {NONE, CPU_READ, CPU_WRITE};
		address : boolean;
		data : boolean;

	DEFINE
		busy := (req = NONE & !L1_req) | (L1_rsp);

	ASSIGN
		init(req) := NONE;
		next(req) := case
			busy : {NONE, CPU_READ, CPU_WRITE};
			TRUE : req;
		esac;
		next(address) := case
			busy : {TRUE, FALSE};
			TRUE : address;
		esac;
		next(data) := case
			busy : {TRUE, FALSE};
			TRUE : data;
		esac;

-- end of cpu_module

MODULE arbiter_module(L1_req, mem_ready)
	VAR
		gnt : {MEM, L1_1};

	DEFINE
		valid := (gnt = MEM & L1_req & !mem_ready) 
				 | (gnt = MEM & mem_ready);

	ASSIGN
		init(gnt) := MEM;
		next(gnt) := case
			gnt = MEM & L1_req & !mem_ready : L1_1;
			gnt  = L1_1 : MEM;
			TRUE : gnt;
		esac;

-- end of arbiter_module

MODULE bus_module(arb_gnt, cpu)
	VAR
		address : boolean;
		data : boolean;
		ctrl : {BUS_READ, BUS_WRITE};

	ASSIGN
		ctrl := case
			arb_gnt = L1_1 & cpu.req = CPU_READ : BUS_READ;
			arb_gnt = L1_1 & cpu.req = CPU_WRITE : BUS_WRITE;
			TRUE : BUS_READ;
		esac;
		data := case
			arb_gnt = L1_1 : cpu.data;
			TRUE : FALSE;
		esac;
		address := case
			arb_gnt = L1_1 : cpu.address;
			TRUE : FALSE;
		esac;

-- end of bus_module

MODULE cache_module(cpu_req, mem_ready, prev_mem_ready)
	DEFINE
		rsp := mem_ready;
		req := (cpu_req = CPU_READ | cpu_req = CPU_WRITE) & !prev_mem_ready;

-- end of cache_module

MODULE main
	VAR
		prev_mem_ready : boolean;
		memory : memory_module(arbiter.gnt = L1_1);
		cpu : cpu_module(L1.req, L1.rsp);
		arbiter : arbiter_module(L1.req, memory.state = READY);
		bus : bus_module(arbiter.gnt, cpu);
		L1 : cache_module(cpu.req, memory.state = READY, prev_mem_ready);

	ASSIGN
		init(prev_mem_ready) := memory.state = READY;
		next(prev_mem_ready) := memory.state = READY;
