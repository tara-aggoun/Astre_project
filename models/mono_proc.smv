MODULE memory_module(b_in_L1)
	VAR
		state : {IDLE, READY};

	ASSIGN
		init(state) := IDLE;
		next(state) := case
			state = IDLE & b_in_L1 : READY;
			state = READY : IDLE;
			TRUE : state;
		esac;


-- end of memory_module

MODULE cpu_module(L1_req, L1_rsp)
	VAR
		req: {IDLE, CPU_READ};

	ASSIGN
		init(req) := IDLE;
		next(req) := case
			req = IDLE & !L1_req : CPU_READ;
			req != IDLE & L1_rsp : {IDLE, CPU_READ};
			TRUE : req;
		esac;

-- end of cpu_module

MODULE arbiter_module(L1_req, mem_ready)
	VAR
		state : {MEM, L1_1};

	DEFINE
		valid := (state = MEM & L1_req & !mem_ready) 
				 | (state = MEM & mem_ready);

	ASSIGN
		init(state) := MEM;
		next(state) := case
			state = MEM & L1_req & !mem_ready : L1_1;
			state = L1_1 : MEM;
			TRUE : state;
		esac;

-- end of arbiter_module

MODULE cache_module(cpu_req, mem_ready, prev_mem_ready)
	DEFINE
		rsp := mem_ready;
		req := (cpu_req = CPU_READ) & !prev_mem_ready;

-- end of cache_module

MODULE main
	VAR
		prev_mem_ready : boolean;
		memory : memory_module(arbiter.state = L1_1);
		cpu : cpu_module(L1.req, L1.rsp);
		arbiter : arbiter_module(L1.req, memory.state = READY);
		L1 : cache_module(cpu.req, memory.state = READY, prev_mem_ready);

	ASSIGN
		init(prev_mem_ready) := memory.state = READY;
		next(prev_mem_ready) := memory.state = READY;
