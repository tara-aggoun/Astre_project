MODULE memory_module(b_in_L1, bus)
	VAR
		valid : boolean;
		data : array 0..1 of {0, 1};
		out : {0, 1, ACK};

	ASSIGN
		init(valid) := FALSE;
		next(valid) := case
			!valid & b_in_L1 : TRUE;
			valid : FALSE;
			TRUE : valid;
		esac;

		init(data[0]) := 0;
		init(data[1]) := 0;
		next(data[0]) := case
			b_in_L1 & bus.address = 0 & bus.ctrl = BUS_WRITE & bus.data = 0 : 0;
			b_in_L1 & bus.address = 0 & bus.ctrl = BUS_WRITE & bus.data = 1 : 1;
			TRUE : data[0];
		esac;
		next(data[1]) := case
			b_in_L1 & bus.address = 1 & bus.ctrl = BUS_WRITE & bus.data = 0 : 0;
			b_in_L1 & bus.address = 1 & bus.ctrl = BUS_WRITE & bus.data = 1 : 1;
			TRUE : data[1];
		esac;

		init(out) := 0;
		next(out) := case
			b_in_L1 & bus.address = 0 & bus.ctrl = BUS_READ & data[0] = 0 : 0;
			b_in_L1 & bus.address = 0 & bus.ctrl = BUS_READ & data[0] = 1 : 1;
			b_in_L1 & bus.address = 1 & bus.ctrl = BUS_READ & data[1] = 0 : 0;
			b_in_L1 & bus.address = 1 & bus.ctrl = BUS_READ & data[1] = 1 : 1;
			b_in_L1 & bus.ctrl = BUS_WRITE : ACK;
			TRUE : out;
		esac;

-- end of memory_module

MODULE cpu_module(L1_req, L1_rsp)
	VAR
		req: {NONE, CPU_READ, CPU_WRITE};
		address : {0, 1};
		data : {0, 1};

	DEFINE
		busy := (req = NONE & !L1_req) | L1_rsp;

	ASSIGN
		init(req) := NONE;
		next(req) := case
			busy : {NONE, CPU_READ, CPU_WRITE};
			TRUE : req;
		esac;

		init(address) := 0;
		next(address) := case
			busy : {0, 1};
			TRUE : address;
		esac;

		init(data) := 0;
		next(data) := case
			busy : {0, 1};
			TRUE : data;
		esac;

-- end of cpu_module

MODULE arbiter_module(L1_req, valid)
	VAR
		gnt : {MEM, L1_1};

	ASSIGN
		init(gnt) := MEM;
		next(gnt) := case
			gnt = MEM & L1_req & !valid : L1_1;
			gnt = L1_1 : MEM;
			TRUE : gnt;
		esac;

-- end of arbiter_module

MODULE bus_module(arb_gnt, L1, mem)
	VAR
		address : {0, 1};
		data : {0, 1, ACK};
		ctrl : {BUS_READ, BUS_WRITE};

	DEFINE
		valid := mem.valid;

	ASSIGN
		data := case
			arb_gnt = MEM : mem.out;
			arb_gnt = L1_1 & L1.data = 0 : 0;
			arb_gnt = L1_1 & L1.data = 1 : 1;
		esac;
		ctrl := case
			arb_gnt = L1_1 & L1.state = L1_READ : BUS_READ;
			arb_gnt = L1_1 & L1.state = L1_WRITE : BUS_WRITE;
			TRUE : BUS_READ;
		esac;
		address := case
			arb_gnt = L1_1 : L1.address;
			TRUE : 0;
		esac;

-- end of bus_module

MODULE cache_module(cpu, bus_out, valid, prev_valid)
	VAR
		rsp : {NONE, 0, 1, ACK};
		state : {IDLE, L1_READ, L1_WRITE};
		address : {0, 1};
		data : {0, 1};

	DEFINE
		req := ((cpu.req != NONE) | (state != IDLE)) & !prev_valid;

	ASSIGN
		next(state) := case
			state = IDLE & cpu.req = CPU_READ : L1_READ;
			state = IDLE & cpu.req = CPU_WRITE : L1_WRITE;
			state != IDLE & prev_valid : IDLE;
			TRUE : state;
		esac;
		next(address) := case
			state = IDLE & cpu.req != NONE : cpu.address;
			TRUE : address;
		esac;
		next(data) := case
			state = IDLE & cpu.req != NONE : cpu.data;
			TRUE : data;
		esac;

		rsp := case
			valid & bus_out = 0 : 0;
			valid & bus_out = 1 : 1;
			valid & bus_out = ACK : ACK;
			TRUE : NONE;
		esac;


-- end of cache_module

MODULE main
	VAR
		prev_valid: boolean;
		memory : memory_module(arbiter.gnt = L1_1, bus);
		cpu : cpu_module(L1.req, L1.rsp != NONE);
		arbiter : arbiter_module(L1.req, bus.valid);
		bus : bus_module(arbiter.gnt, L1, memory);
		L1 : cache_module(cpu, bus.data, bus.valid, prev_valid);

	ASSIGN
		init(prev_valid) := bus.valid;
		next(prev_valid) := bus.valid;
